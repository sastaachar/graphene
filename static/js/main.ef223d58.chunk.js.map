{"version":3,"sources":["reportWebVitals.ts","dataStructures/queue.ts","dataStructures/stack.ts","dataStructures/priorityQueue.ts","store/nodeManager/algorithms/helpers.ts","store/nodeManager/algorithms/bfs.ts","store/nodeManager/algorithms/dfs.ts","store/nodeManager/algorithms/dijkstra.ts","store/nodeManager/models/nodeManagerActionTypes.ts","store/nodeManager/nodeManagerActions.ts","components/pages/main/gnode/gnode.tsx","components/pages/main/path/path.tsx","components/pages/main/nodeManager/nodeManager.tsx","store/path/models/path.ts","store/gnode/models/gnode.ts","App.tsx","store/nodeManager/nodeManagerReducer.ts","store/rootStore.ts","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Queue","queue","this","length","shift","element","push","Stack","stack","unshift","Lesser","a","b","PriorityQueue","compare","pQueue","ele","left","right","midPos","Math","floor","pos","getPos","splice","visitNode","node","newNode","visited","bfs","graph","updateNode","rootID","console","log","q","delay","curId","pop","cur","nodes","id","setTimeout","connections","forEach","conn","nodeID","empty","dfs","s","dijkstra","updatePath","costs","cost","pred","pathID","parentID","Object","values","Infinity","curNode","pathCost","paths","weight","destinationID","prev","connPath","path","newPath","state","visitPath","ADD_NODE","UPDATE_NODE","ADD_PATH","SET_ROOT","UNVISIT_ALL","UPDATE_PATH","SET_DESTINATION","updatedNode","type","payload","Gnode","props","bgColor","gnode","style","x","top","y","backgroundColor","className","onClick","onNodeSelect","data","mapDispatchToProps","Path","connect","connector","stroke","width","height","x1","sourcePos","y1","x2","destinationPos","y2","addGnode","addPath","setRoot","unvisitAll","updatedPath","setDestination","nodeManager","NodeManager","useState","inputData","setInputData","panelState","setPanelState","boardRef","useRef","sourceNode","setSourceNode","unselectSourceNode","selectedNode","updateNodePairs","i","source","destination","uuidv4","sourceId","destinationId","updateNodeSelection","value","onChange","e","target","nodeValue","parseInt","newGnode","pageX","current","offsetLeft","scrollLeft","pageY","offsetTop","scrollTop","ref","map","App","defaultState","rootReducer","combineReducers","action","newState","oldConnections","previousNode","previousPath","keys","rootStore","createStore","composeWithDevTools","ReactDOM","render","StrictMode","store","document","getElementById"],"mappings":"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","file":"static/js/main.ef223d58.chunk.js","sourcesContent":["import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export default class Queue<T> {\n  private queue: T[];\n\n  constructor() {\n    this.queue = [];\n  }\n\n  front(): T | undefined {\n    if (this.queue.length === 0) return undefined;\n    return this.queue[0];\n  }\n\n  pop(): T | undefined {\n    // remove from front\n    return this.queue.shift();\n  }\n\n  push(element: T) {\n    // add at rear\n    this.queue.push(element);\n  }\n\n  empty(): boolean {\n    return this.queue.length === 0;\n  }\n}\n","export default class Stack<T> {\n  private stack: T[];\n\n  constructor() {\n    this.stack = [];\n  }\n\n  top(): T | undefined {\n    if (this.stack.length === 0) return undefined;\n    return this.stack[0];\n  }\n\n  pop(): T | undefined {\n    // remove from front\n    return this.stack.shift();\n  }\n\n  push(element: T) {\n    // add at front\n    this.stack.unshift(element);\n  }\n\n  empty(): boolean {\n    return this.stack.length === 0;\n  }\n}\n","export function Lesser<T>(a: T, b: T): boolean {\n  return a <= b;\n}\nexport function Greater<T>(a: T, b: T): boolean {\n  return a >= b;\n}\n\nexport type Comparator<T> = (a: T, b: T) => boolean;\n\nexport default class PriorityQueue<T> {\n  private pQueue: T[];\n  private compare: Comparator<T>;\n\n  private getPos(ele: T, left: number, right: number): number {\n    while (left <= right) {\n      if (left === right) {\n        return this.compare(ele, this.pQueue[left]) ? left : left + 1;\n      }\n      const midPos = Math.floor((left + right) / 2);\n\n      if (this.compare(ele, this.pQueue[midPos])) {\n        right = midPos - 1;\n      } else {\n        left = midPos + 1;\n      }\n    }\n\n    return 0;\n  }\n\n  constructor(compare: Comparator<T> = Lesser) {\n    this.pQueue = [];\n    this.compare = compare;\n  }\n\n  front(): T | undefined {\n    if (this.pQueue.length === 0) return undefined;\n    return this.pQueue[0];\n  }\n\n  pop(): T | undefined {\n    // remove from front\n    return this.pQueue.shift();\n  }\n\n  push(element: T) {\n    const pos = this.getPos(element, 0, this.pQueue.length - 1);\n    this.pQueue.splice(pos, 0, element);\n  }\n\n  empty(): boolean {\n    return this.pQueue.length === 0;\n  }\n}\n","import { IGnode } from '../../gnode/models';\nimport { IPath } from '../../path/models';\n\nexport interface Visited {\n  [key: string]: boolean;\n}\n\nexport const visitNode = (node: IGnode) => {\n  const newNode = { ...node };\n  newNode.visited = true;\n  return newNode;\n};\n\nexport const visitPath = (path: IPath) => {\n  const newPath = { ...path };\n  newPath.state = 'travel';\n  return newPath;\n};\n","import { Queue } from '../../../dataStructures';\nimport { IGnode } from '../../gnode/models';\nimport { IGraph } from '../models';\nimport { UpdateNodeAction } from '../models/nodeManagerActionTypes';\nimport { Visited, visitNode } from './helpers';\n\nconst bfs = (graph: IGraph, updateNode: (x: IGnode) => UpdateNodeAction) => {\n  if (!graph.rootID) {\n    console.log('Root is not set');\n    return;\n  }\n\n  console.log('Starting BFS');\n\n  const q = new Queue<string>();\n  q.push(graph.rootID);\n\n  const visited: Visited = {};\n\n  let delay: number = 0;\n\n  while (!q.empty()) {\n    const curId = q.pop() as string;\n    console.log(curId);\n    const cur = graph.nodes[curId];\n    visited[cur.id] = true;\n\n    setTimeout(() => {\n      updateNode(visitNode(cur));\n    }, delay);\n\n    delay += 300;\n\n    graph.nodes[cur.id].connections.forEach((conn) => {\n      if (!visited[conn.nodeID]) q.push(conn.nodeID);\n    });\n  }\n\n  console.log('BFS finished');\n};\n\nexport default bfs;\n","import { Stack } from '../../../dataStructures';\nimport { IGnode } from '../../gnode/models';\nimport { IGraph } from '../models';\nimport { UpdateNodeAction } from '../models/nodeManagerActionTypes';\nimport { Visited, visitNode } from './helpers';\n\nconst dfs = (graph: IGraph, updateNode: (x: IGnode) => UpdateNodeAction) => {\n  if (!graph.rootID) {\n    console.log('Root is not set');\n    return;\n  }\n\n  console.log('Starting DFS');\n\n  const s = new Stack<string>();\n  s.push(graph.rootID);\n\n  const visited: Visited = {};\n\n  let delay: number = 0;\n\n  while (!s.empty()) {\n    const curId = s.pop() as string;\n    console.log(curId);\n    const cur = graph.nodes[curId];\n    visited[cur.id] = true;\n\n    setTimeout(() => {\n      updateNode(visitNode(cur));\n    }, delay);\n\n    delay += 300;\n\n    graph.nodes[cur.id].connections.forEach((conn) => {\n      if (!visited[conn.nodeID]) s.push(conn.nodeID);\n    });\n  }\n\n  console.log('DFS finished');\n};\n\nexport default dfs;\n","import { PriorityQueue } from '../../../dataStructures';\nimport { IGnode } from '../../gnode/models';\nimport { IPath } from '../../path/models';\nimport { IGraph } from '../models';\nimport { UpdateNodeAction, UpdatePathAction } from '../models/nodeManagerActionTypes';\nimport { Visited, visitNode, visitPath } from './helpers';\n\n// there should be no negative weights\n\ninterface PathCost {\n  cost: number;\n  nodeID: string;\n}\n\ninterface Costs {\n  [key: string]: number;\n}\ntype PrevState = {\n  pathID: string | null;\n  parentID: string | null;\n};\ninterface Predecessor {\n  [key: string]: PrevState;\n}\n\nconst dijkstra = (\n  graph: IGraph,\n  updateNode: (x: IGnode) => UpdateNodeAction,\n  updatePath: (x: IPath) => UpdatePathAction,\n) => {\n  if (!graph.rootID) {\n    console.log('Root is not set');\n    return;\n  }\n\n  console.log('Starting Dijkstra');\n\n  const compare = (a: PathCost, b: PathCost): boolean => {\n    return a.cost >= b.cost;\n  };\n\n  const costs: Costs = {};\n  const visited: Visited = {};\n  const q = new PriorityQueue<PathCost>(compare);\n\n  const pred: Predecessor = {};\n\n  pred[graph.rootID] = { pathID: null, parentID: null };\n\n  Object.values(graph.nodes).forEach((node) => {\n    costs[node.id] = Infinity;\n  });\n\n  costs[graph.rootID] = 0;\n  q.push({ cost: 0, nodeID: graph.rootID });\n\n  let delay: number = 0;\n\n  while (!q.empty()) {\n    const cur = q.pop() as PathCost;\n\n    console.log(cur.nodeID);\n    const curNode = graph.nodes[cur.nodeID];\n    visited[cur.nodeID] = true;\n\n    setTimeout(() => {\n      updateNode(visitNode(curNode));\n    }, delay);\n\n    delay += 300;\n\n    graph.nodes[cur.nodeID].connections.forEach((conn) => {\n      const pathCost = graph.paths[conn.pathID].weight ?? 10;\n      if (!visited[conn.nodeID] && costs[conn.nodeID] > cur.cost + pathCost) {\n        console.log('here');\n        costs[conn.nodeID] = cur.cost + pathCost;\n        q.push({ cost: costs[conn.nodeID], nodeID: conn.nodeID });\n        pred[conn.nodeID] = { parentID: cur.nodeID, pathID: conn.pathID };\n      }\n    });\n  }\n\n  console.log(pred);\n\n  if (graph.destinationID) {\n    // destination id is set so we can find path\n\n    // check if no path exists\n\n    let prev: string | null = graph.destinationID;\n\n    while (prev) {\n      // update path\n\n      const connPath: PrevState = pred[prev];\n\n      if (!connPath) {\n        // prev was never visted\n        console.log(\"Can't reach \", prev);\n        break;\n      }\n      setTimeout(() => {\n        if (connPath.pathID) updatePath(visitPath(graph.paths[connPath.pathID]));\n        // ! needs to be better\n        else console.log(connPath, ' ERROR pathID empty');\n      }, delay);\n\n      delay += 300;\n      prev = connPath.parentID;\n    }\n  }\n\n  console.log(costs);\n  console.log('Dijkstra finished');\n};\n\nexport default dijkstra;\n","import { IGnode } from '../../gnode/models';\nimport { IPath } from '../../path/models';\n\n// ACTION TYPES\nexport const ADD_NODE = 'ADD_NODE';\nexport interface AddGnodeAction {\n  type: typeof ADD_NODE;\n  payload: { gnode: IGnode };\n}\nexport const REMOVE_NODE = 'REMOVE_NODE';\nexport interface RemoveGnodeAction {\n  type: typeof REMOVE_NODE;\n  payload: { nodeID: string };\n}\nexport const UPDATE_NODE = 'UPDATE_NODE';\n\nexport interface UpdateNodeAction {\n  type: typeof UPDATE_NODE;\n  payload: { updatedNode: IGnode };\n}\n\nexport const ADD_PATH = 'ADD_PATH';\n\nexport interface AddPathAction {\n  type: typeof ADD_PATH;\n  payload: { path: IPath };\n}\nexport const REMOVE_PATH = 'REMOVE_PATH';\nexport interface RemovePathAction {\n  type: typeof REMOVE_PATH;\n  payload: { pathID: string };\n}\n\nexport const SET_ROOT = 'SET_ROOT';\nexport interface SetRootAction {\n  type: typeof SET_ROOT;\n  payload: { nodeID: string };\n}\n\nexport const UNVISIT_ALL = 'UNVISIT_ALL';\nexport interface UnvisitAllAction {\n  type: typeof UNVISIT_ALL;\n}\n\nexport const UPDATE_PATH = 'UPDATE_PATH';\n\nexport interface UpdatePathAction {\n  type: typeof UPDATE_PATH;\n  payload: { updatedPath: IPath };\n}\n\nexport const SET_DESTINATION = 'SET_DESTINATION';\n\nexport interface SetDestinationAction {\n  type: typeof SET_DESTINATION;\n  payload: { nodeID: string };\n}\n\nexport type NodeMangerAction =\n  | AddGnodeAction\n  | RemoveGnodeAction\n  | AddPathAction\n  | RemovePathAction\n  | UpdateNodeAction\n  | SetRootAction\n  | UnvisitAllAction\n  | UpdatePathAction\n  | SetDestinationAction;\n","// action creator\n\nimport { IGnode } from '../gnode/models';\nimport { IPath } from '../path/models';\nimport {\n  AddGnodeAction,\n  ADD_NODE,\n  AddPathAction,\n  ADD_PATH,\n  UpdateNodeAction,\n  UPDATE_NODE,\n  SetRootAction,\n  SET_ROOT,\n  UnvisitAllAction,\n  UNVISIT_ALL,\n  UpdatePathAction,\n  UPDATE_PATH,\n  SetDestinationAction,\n  SET_DESTINATION,\n} from './models/nodeManagerActionTypes';\n\nexport const addGnode = (gnode: IGnode): AddGnodeAction => ({\n  type: ADD_NODE,\n  payload: { gnode },\n});\n\nexport const addPath = (path: IPath): AddPathAction => ({\n  type: ADD_PATH,\n  payload: { path },\n});\n\nexport const updateNode = (updatedNode: IGnode): UpdateNodeAction => ({\n  type: UPDATE_NODE,\n  payload: { updatedNode },\n});\n\nexport const setRoot = (nodeID: string): SetRootAction => ({\n  type: SET_ROOT,\n  payload: { nodeID },\n});\n\nexport const unvisitAll = (): UnvisitAllAction => ({\n  type: UNVISIT_ALL,\n});\n\nexport const updatePath = (updatedPath: IPath): UpdatePathAction => ({\n  type: UPDATE_PATH,\n  payload: { updatedPath },\n});\n\nexport const setDestination = (nodeID: string): SetDestinationAction => ({\n  type: SET_DESTINATION,\n  payload: { nodeID },\n});\n","import React, { CSSProperties } from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\n\nimport { IGnode } from '../../../../store/gnode/models';\n\nimport { updateNode } from '../../../../store/nodeManager/nodeManagerActions';\n\nimport './gnode.scss';\n\ninterface Props extends PropsFromRedux {\n  gnode: IGnode;\n  onNodeSelect: (node: IGnode) => void;\n}\n\nexport const Gnode: React.FC<Props> = (props: Props) => {\n  const isSelected = props.gnode.state === 'selected';\n  const bgColor: string = isSelected ? 'var(--yellow)' : props.gnode.visited ? 'var(--green)' : 'var(--primary)';\n\n  const style: CSSProperties = {\n    left: props.gnode.pos.x,\n    top: props.gnode.pos.y,\n    backgroundColor: bgColor,\n  };\n\n  const handleOnClick = () => {\n    props.onNodeSelect(props.gnode);\n  };\n\n  return (\n    <div className=\"gnode\" style={style} onClick={handleOnClick}>\n      <div className=\"gnode-inner\">\n        <span className=\"gnode-inner-content\">{props.gnode.data}</span>\n      </div>\n    </div>\n  );\n};\n\nconst mapStateToProps = () => ({});\nconst mapDispatchToProps = {\n  updateNode,\n};\n\nconst connector = connect(mapStateToProps, mapDispatchToProps);\ntype PropsFromRedux = ConnectedProps<typeof connector>;\n\nexport default connector(Gnode);\n","import React, { CSSProperties } from 'react';\nimport { IPath } from '../../../../store/path/models';\n\nimport './path.scss';\n\ninterface Props {\n  path: IPath;\n}\n\nexport const Path: React.FC<Props> = (props) => {\n  const style: CSSProperties = { stroke: props.path.state === 'travel' ? 'var(--green)' : 'var(--primary-darker)' };\n  return (\n    <svg className=\"path\" width=\"100%\" height=\"100%\">\n      <line\n        x1={props.path.sourcePos.x + 50}\n        y1={props.path.sourcePos.y + 50}\n        x2={props.path.destinationPos.x + 50}\n        y2={props.path.destinationPos.y + 50}\n        style={style}\n      />\n    </svg>\n  );\n};\n","import React, { MouseEvent, useRef, useState } from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\n\nimport { createGnode, IGnode } from '../../../../store/gnode/models';\nimport { bfs, dfs, dijkstra } from '../../../../store/nodeManager/algorithms';\nimport {\n  addGnode,\n  addPath,\n  setDestination,\n  setRoot,\n  unvisitAll,\n  updateNode,\n  updatePath,\n} from '../../../../store/nodeManager/nodeManagerActions';\nimport { createPath } from '../../../../store/path/models';\nimport { AppState } from '../../../../store/rootStore';\nimport { Gnode } from '../gnode';\nimport { Path } from '../path';\n\nimport './nodemanager.scss';\n\ninterface Props extends PropsFromRedux {}\n\nconst NodeManager: React.FC<Props> = (props: Props) => {\n  const [inputData, setInputData] = useState('');\n  const [panelState, setPanelState] = useState(0);\n  const boardRef = useRef<HTMLDivElement>(null);\n\n  const createNodeOnClick = (e: MouseEvent<HTMLDivElement>) => {\n    if (panelState != 0) return;\n    if (inputData) {\n      const nodeValue = parseInt(inputData);\n      if (!nodeValue) return;\n      const newGnode = createGnode(nodeValue, {\n        x: e.pageX - (boardRef.current?.offsetLeft ?? 0) - 50 + (boardRef.current?.scrollLeft ?? 0),\n        y: e.pageY - (boardRef.current?.offsetTop ?? 0) - 50 + (boardRef.current?.scrollTop ?? 0),\n      });\n      props.addGnode(newGnode);\n    }\n  };\n\n  const [sourceNode, setSourceNode] = useState<IGnode | null>(null);\n\n  const unselectSourceNode = () => {\n    if (!sourceNode) return;\n    // we need to use the latest version to update\n    // TODO : use a property based update system\n    const selectedNode = props.nodeManager.graph.nodes[sourceNode.id];\n    selectedNode.state = 'default';\n    props.updateNode(selectedNode);\n    setSourceNode(null);\n  };\n  const updateNodePairs = (node: IGnode) => {\n    if (!sourceNode) {\n      setSourceNode(node);\n      node.state = 'selected';\n      props.updateNode(node);\n      return;\n    }\n    // source is set\n\n    if (node.id === sourceNode.id) {\n      // no self loops for now\n      console.log('No self loops');\n      unselectSourceNode();\n      return;\n    }\n\n    // check if path already exists\n    const connections = props.nodeManager.graph.nodes[sourceNode.id].connections;\n    for (let i = 0; i < connections.length; i++) {\n      const conn = connections[i];\n      if (conn.nodeID === node.id) {\n        // path already exists\n        console.log('Path already exists');\n        unselectSourceNode();\n        return;\n      }\n    }\n\n    const newPath = createPath(sourceNode, node);\n    props.addPath(newPath);\n\n    // const newPath = createPath();\n    // updateGnode  -> connections updated\n    // updateGraph  -> adding path to paths\n    unselectSourceNode();\n    return;\n  };\n\n  const updateNodeSelection = (node: IGnode) => {\n    // node is selected : do stuff to handle that\n    switch (panelState) {\n      case 1:\n        // update node pairs to create path\n        updateNodePairs(node);\n        break;\n      case 2:\n        // set node as root\n        props.setRoot(node.id);\n        break;\n\n      case 3:\n        props.setDestination(node.id);\n        break;\n      default:\n        break;\n    }\n  };\n\n  // 0 -> create node\n  // 1 -> create path\n  // 2 -> set Root\n  return (\n    <div className=\"nodemanager\">\n      <div className=\"left-panel\">\n        <input type=\"text\" value={inputData} onChange={(e) => setInputData(e.target.value)} />\n        <button onClick={() => setPanelState(0)}>create node</button>\n        <button onClick={() => setPanelState(1)}>create path</button>\n        <button onClick={() => setPanelState(2)}>set root</button>\n        <button onClick={() => setPanelState(3)}>set destination</button>\n        <button onClick={() => props.unvisitAll()}>unvisit all</button>\n        <button onClick={() => bfs(props.nodeManager.graph, props.updateNode)}>bfs</button>\n        <button onClick={() => dfs(props.nodeManager.graph, props.updateNode)}>dfs</button>\n        <button onClick={() => dijkstra(props.nodeManager.graph, props.updateNode, props.updatePath)}>dijkstra</button>\n      </div>\n      <div className=\"right-panel\" onClick={createNodeOnClick} ref={boardRef}>\n        {Object.values(props.nodeManager.graph.nodes).map((node) => (\n          //! FIX : need to pass updateNode here or typescript starts crying\n          <Gnode key={node.id} gnode={node} onNodeSelect={updateNodeSelection} updateNode={updateNode} />\n        ))}\n        {Object.values(props.nodeManager.graph.paths).map((path) => (\n          <Path key={path.id} path={path} />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nconst mapStateToProps = (state: AppState) => ({\n  nodeManager: state.NodeManager,\n});\nconst mapDispatchToProps = {\n  addGnode,\n  addPath,\n  setRoot,\n  updateNode,\n  unvisitAll,\n  updatePath,\n  setDestination,\n};\n\nconst connector = connect(mapStateToProps, mapDispatchToProps);\ntype PropsFromRedux = ConnectedProps<typeof connector>;\n\nexport default connector(NodeManager);\n","import { v4 as uuidv4 } from 'uuid';\n\nimport { Position } from '../../sharedModels';\n\ntype PathState = 'default' | 'travel';\n\nexport interface IPath {\n  id: string;\n  sourceId: string;\n  destinationId: string;\n  sourcePos: Position;\n  destinationPos: Position;\n  state: PathState;\n  weight?: number;\n}\n\nexport const createPath = (\n  source: { id: string; pos: Position },\n  destination: { id: string; pos: Position },\n): IPath => {\n  return {\n    id: uuidv4(),\n    sourceId: source.id,\n    destinationId: destination.id,\n    sourcePos: source.pos,\n    destinationPos: destination.pos,\n    state: 'default',\n  };\n};\n","import { v4 as uuidv4 } from 'uuid';\nimport { Position } from '../../sharedModels';\n\ntype NodeStates = 'default' | 'root' | 'selected';\n\nexport interface Connection {\n  nodeID: string;\n  pathID: string;\n}\nexport interface IGnode {\n  id: string;\n  data: number;\n  visited: boolean;\n  state: NodeStates;\n  connections: Connection[];\n  pos: Position;\n}\n\nexport const createGnode = (data: number, pos: Position): IGnode => {\n  return {\n    id: uuidv4(),\n    data,\n    state: 'default',\n    visited: false,\n    connections: [],\n    pos,\n  };\n};\n","import React from 'react';\n\nimport { NodeManager } from './components/pages/main/nodeManager';\n\nimport './App.scss';\n\nconst App: React.FC<{}> = () => {\n  return <NodeManager></NodeManager>;\n};\n\nexport default App;\n","import { Reducer } from 'redux';\nimport { IPath } from '../path/models';\n\nimport { INodeManager } from './models';\nimport {\n  ADD_NODE,\n  ADD_PATH,\n  NodeMangerAction,\n  SET_DESTINATION,\n  SET_ROOT,\n  UNVISIT_ALL,\n  UPDATE_NODE,\n  UPDATE_PATH,\n} from './models/nodeManagerActionTypes';\n\nconst defaultState: INodeManager = {\n  graph: {\n    nodes: {},\n    paths: {},\n  },\n};\n\nexport const NodeManagerReducer: Reducer<INodeManager, NodeMangerAction> = (\n  state = defaultState,\n  action: NodeMangerAction,\n): INodeManager => {\n  const newState: INodeManager = { ...state };\n  switch (action.type) {\n    // adds a new node to state\n    case ADD_NODE: {\n      const newNode = action.payload.gnode;\n      newState.graph.nodes = { ...newState.graph.nodes, [newNode.id]: newNode };\n      return newState;\n    }\n    // adds a new path to state\n    case ADD_PATH: {\n      const newPath = action.payload.path;\n      newState.graph.paths = { ...newState.graph.paths, [newPath.id]: newPath };\n      const oldConnections = newState.graph.nodes[newPath.sourceId].connections;\n      newState.graph.nodes[newPath.sourceId].connections = [\n        ...oldConnections,\n        { nodeID: newPath.destinationId, pathID: newPath.id },\n      ];\n      return newState;\n    }\n    // might regret this later\n    case UPDATE_NODE: {\n      const { updatedNode } = action.payload;\n      const previousNode = newState.graph.nodes[updatedNode.id];\n      if (!previousNode) {\n        return state;\n      }\n      // update the node\n      newState.graph.nodes[updatedNode.id] = { ...previousNode, ...updatedNode };\n      return newState;\n    }\n    case UPDATE_PATH: {\n      const { updatedPath } = action.payload;\n      const previousPath: IPath = newState.graph.paths[updatedPath.id];\n      if (!previousPath) {\n        return state;\n      }\n      // update the path\n      newState.graph.paths[updatedPath.id] = { ...previousPath, ...updatedPath };\n      return newState;\n    }\n    case SET_ROOT: {\n      const { nodeID } = action.payload;\n      if (!newState.graph.nodes[nodeID]) {\n        return state;\n      }\n      newState.graph.rootID = nodeID;\n      return newState;\n    }\n    case UNVISIT_ALL: {\n      Object.keys(newState.graph.nodes).forEach((nodeID) => {\n        newState.graph.nodes[nodeID].visited = false;\n      });\n      return newState;\n    }\n    case SET_DESTINATION: {\n      const { nodeID } = action.payload;\n      if (!newState.graph.nodes[nodeID]) {\n        return state;\n      }\n      newState.graph.destinationID = nodeID;\n      return newState;\n    }\n    default:\n      return state;\n  }\n};\n","import { combineReducers, createStore, Store } from 'redux';\n\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport { NodeManagerReducer } from './nodeManager/nodeManagerReducer';\n\nconst rootReducer = combineReducers({ NodeManager: NodeManagerReducer });\nexport type AppState = ReturnType<typeof rootReducer>;\n\nexport const rootStore: Store = createStore(rootReducer, composeWithDevTools());\nexport type AppDispatch = typeof rootStore.dispatch;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport reportWebVitals from './reportWebVitals';\n\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport { rootStore } from './store';\n\nimport './index.scss';\nimport './reset.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={rootStore}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log);\n"],"sourceRoot":""}